{"1325_bronze_rotate_and_shift": {
                "name": "Rotate and Shift",
                "problem_link": "http://www.usaco.org/index.php?page=viewproblem2&cpid=1325",
                "test_data_link": "http://www.usaco.org/current/data/prob3_bronze_open23.zip",
                "solution_link": "http://www.usaco.org/current/data/sol_prob3_bronze_open23.html",
                "contest_link": "http://www.usaco.org/index.php?page=open23results",
                "inner_contest_link": "http://www.usaco.org/index.php?page=nov11problems",
                "problem_level": "bronze",
                "cp_id": "1325",
                "problem_id": "1325_bronze_rotate_and_shift",
                "description": "\n**Note: The time limit for this problem is 4s, 2x the default.**\nTo celebrate the start of spring, Farmer John's $N$ cows ($1 \\leq N \\leq 2 \\cdot 10^5$) have invented an intriguing new dance, where they stand in a circle and re-order themselves in a predictable way.\n\nSpecifically, there are $N$ positions around the circle, numbered sequentially from $0$ to $N-1$, with position $0$ following position $N-1$.  A cow resides at each position.  The cows are also numbered sequentially from $0$ to $N-1$.  Initially, cow $i$ starts in position $i$.  You are told a set of $K$ positions $0=A_1<A_2< \\ldots< A_K<N$ that are \"active\", meaning the cows in these positions are the next to move ($1 \\leq K \\leq N$).  \n\nIn each minute of the dance, two things happen.  First, the cows in the active positions rotate: the cow at position $A_1$ moves to position $A_2$, the cow at position $A_2$ moves to position $A_3$, and so on, with the cow at position $A_K$ moving to position $A_1$.  All of these $K$ moves happen simultaneously, so the after the rotation is complete, all of the active positions still contain exactly one cow.  Next, the active positions themselves shift:\n$A_1$ becomes $A_1+1$, $A_2$ becomes $A_2+1$, and so on (if $A_i = N-1$ for some active position, then $A_i$ circles back around to $0$).\n\nPlease calculate the order of the cows after $T$ minutes of the dance ($1\\le T\\le 10^9$).\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains three integers $N$, $K$, and $T$.\n\nThe second line contains $K$ integers representing the initial set of active positions\n$A_1,A_2, \\ldots A_K$.  Recall that $A_1 = 0$ and that these are given in increasing order.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the order of the cows after $T$ minutes, starting with the cow in position $0$, separated by\nspaces.\n\nSAMPLE INPUT:\n5 3 4\n0 2 3\nSAMPLE OUTPUT: \n1 2 3 4 0\n\nFor the example above, here are the cow orders and $A$ for the first four\ntimesteps:\n\n\nInitial, T = 0: order = [0 1 2 3 4], A = [0 2 3]\nT = 1: order = [3 1 0 2 4]\nT = 1: A = [1 3 4]\nT = 2: order = [3 4 0 1 2]\nT = 2: A = [2 4 0]\nT = 3: order = [2 4 3 1 0]\nT = 3: A = [3 0 1]\nT = 4: order = [1 2 3 4 0]\n\nSCORING:\nInputs 2-7: $N \\leq 1000, T \\leq 10000$Inputs 8-13: No additional constraints.\n\n\nProblem credits: Claire Zhang\n",
                "num_tests": 13,
                "solution": "\n(Analysis by Richard Qi)\nFor $N \\le 1000, T \\le 10000$, we can directly simulate the process described by\nthe problem. Initialize an array corresponding to the current order of the cows\n($0$ to $N-1$). Call this array \"order\". \nFor each timestep, first update \"order\" by shifting according to the indices\nlisted in $A$ (you can create a copy of \"order\" and change the values in the\ncopy, or swap/change the values in place). Then, update $A$ by adding one to\neach element and taking modulo $N$. \nRichard's code (C++):\n\n#include <bits/stdc++.h>\nusing namespace std;\n \nconst int mx = 200005;\nint A[mx];\nint ans[mx];\n \nint main(){\n    cin.tie(0)->sync_with_stdio(0);\n    int N, K, T; cin >> N >> K >> T;\n    for(int i = 1; i <= K; i++){\n        cin >> A[i];\n    }\n \n    for(int i = 0; i < N; i++){\n        ans[i] = i;\n    }\n \n    for(int t = 1; t <= T; t++){\n        //active positions rotate\n        vector<int> vals;\n        for(int i = 1; i <= K; i++){\n            vals.push_back(ans[A[i]]);\n        }\n        for(int i = 0; i < K; i++){\n            ans[A[i+1]] = vals[(i-1+(vals.size())) % (vals.size())];\n        }\n        for(int i = 1; i <= K; i++){\n            A[i] = (A[i]+1) % N;\n        }\n    }\n    for(int i = 0; i < N; i++){\n        cout << ans[i];\n        if(i+1 < N) cout << \" \";\n    }\n    cout << \"\\n\";\n}\n\nFor the full solution, it helps to work out some examples of the process on\npaper, or use your brute force solution to list out some examples for you.\nHere's the output of a brute force solution on a slightly larger test case:\n\nINPUT\nN=10 K=3 T=15\nA=[0, 3, 7]\nSIMULATING\nInitial, T = 0: order = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], A = [0, 3, 7]\nT = 1: order = [7, 1, 2, 0, 4, 5, 6, 3, 8, 9]\nT = 1: A = [1, 4, 8]\nT = 2: order = [7, 8, 2, 0, 1, 5, 6, 3, 4, 9]\nT = 2: A = [2, 5, 9]\nT = 3: order = [7, 8, 9, 0, 1, 2, 6, 3, 4, 5]\nT = 3: A = [3, 6, 0]\nT = 4: order = [6, 8, 9, 7, 1, 2, 0, 3, 4, 5]\nT = 4: A = [4, 7, 1]\nT = 5: order = [6, 3, 9, 7, 8, 2, 0, 1, 4, 5]\nT = 5: A = [5, 8, 2]\nT = 6: order = [6, 3, 4, 7, 8, 9, 0, 1, 2, 5]\nT = 6: A = [6, 9, 3]\nT = 7: order = [6, 3, 4, 5, 8, 9, 7, 1, 2, 0]\nT = 7: A = [7, 0, 4]\nT = 8: order = [1, 3, 4, 5, 6, 9, 7, 8, 2, 0]\nT = 8: A = [8, 1, 5]\nT = 9: order = [1, 2, 4, 5, 6, 3, 7, 8, 9, 0]\nT = 9: A = [9, 2, 6]\nT = 10: order = [1, 2, 0, 5, 6, 3, 4, 8, 9, 7]\nT = 10: A = [0, 3, 7]\nT = 11: order = [8, 2, 0, 1, 6, 3, 4, 5, 9, 7]\nT = 11: A = [1, 4, 8]\nT = 12: order = [8, 9, 0, 1, 2, 3, 4, 5, 6, 7]\nT = 12: A = [2, 5, 9]\nT = 13: order = [8, 9, 7, 1, 2, 0, 4, 5, 6, 3]\nT = 13: A = [3, 6, 0]\nT = 14: order = [4, 9, 7, 8, 2, 0, 1, 5, 6, 3]\nT = 14: A = [4, 7, 1]\nT = 15: order = [4, 5, 7, 8, 9, 0, 1, 2, 6, 3]\n\nTry looking at the above output; notice any patterns? There are two similar\nsolutions that naturally follow from patterns that can be found in the above\noutput. The solution code for each solution is at the bottom of the page.\n Solution 1:   Look at a single cow's journey over time. For example,\nlook at cow $0$. Cow $0$ started at position $0$ at $T = 0$, then was at\nposition $3$ during $1 \\le T \\le 3$, then was at position $6$ during\n$4 \\le T \\le 6$. Other than $T=0$, cow $0$ appears to stay at a position for\nexactly $3$ minutes, then move $3$ positions forward, then stay at that position\nfor exactly $3$ minutes, etc.\nThis is no coincidence: cow $1$ follows the same behavior! Cow $1$ starts at\nposition $1$ for $0 \\le T \\le 1$, then goes to position $4$ for $2 \\le T \\le 4$,\nthen goes to position $7$ for $5 \\le T \\le 7$. In fact, if you examine further,\ncow $2$ also exhibits this behavior, moving $3$ positions forward every $3$\nminutes. Cow $3$ moves $4$ positions forward every $4$ minutes, which is\nslightly different from cows $0-2$, but still follows the pattern of moving $i$\npositions every $i$ minutes. \nA natural question to ask is \"why is this happening?\". We will prove why this is\nhappening for cow $2$. Because $A_1 = 0$ and $A_2 = 3$, cow $2$ is \"between\"\nthese two active positions and does not move until $T = 2$, when\n$A_1 = 2, A_2 = 5$. During this timestep, cow $2$ moves to position $5$. So,\nafter this timestep, cow $2$ is at position $5$, $A_1 = 3, A_2 = 6$. Notice that\nat the very beginning of timestep $T=3$, cow $2$ is still between the active\npositions $A_1$ and $A_2$. In fact, cow $2$ is exactly two positions after $A_1$\nand $1$ position before $A_2$, which was true at $T=0$ as well.\nThis motivates looking at cow $2$ in the following way: observe cow $2$ relative\nto active positions $A_1$ and $A_2$. Cow $2$ is always between $A_1$ and $A_2$,\nbecause cow $2$ stays in place while $A_1$ and $A_2$ increase at a rate of $1$\nunit per second, and as soon as $A_1$ is equal to the position of cow $1$, cow\n$1$ jumps ahead $A_2-A_1$ positions and is now just behind position $A_2$. This\nalso shows why cow $j$ jumps exactly $A_{i+1}-A_i$ positions every $A_{i+1}-A_i$\ntimesteps (if $A_i \\le j < A_{i+1}$).\nWe use the above observation to solve the problem in the following way: first,\ndefine $A_{K+1} = N$ for convenience. Then, for each $i$ from $i=1$ to $i=K$,\nconsider all cows $j$ in the range $A_i \\le j < A_{i+1}$.\nCow $j$ first stays in place for $j-A_i$ minutes, during which $A_i$ increases\nto meet $j$. Then, on the $j-A_i+1$th minute, $j$ jumps forward $A_{i+1}-A_i$\npositions.\nAfter this point, there are $T' = T-(j-A_i+1)$ minutes left to go. From then on,\nevery $A_{i+1}-A_i$ minutes, cow $j$'s position increases by $A_{i+1}-A_i$. So,\nduring this phase, cow $j$'s position increases\n$\\lfloor \\frac{T'}{A_{i+1}-A_i} \\rfloor$ times, and each time, cow $j$'s\nposition increases by $A_{i+1}-A_i$ positions, for a total position increase of\n$\\lfloor \\frac{T'}{A_{i+1}-A_i} \\rfloor \\cdot (A_{i+1}-A_i)$.\nWe can compute this quantity in $\\mathcal O \\left(1 \\right)$ time for every\nposition $j$, for a total time complexity of $\\mathcal O \\left(N \\right)$.\n Solution 2:  Instead of having the active positions shift by $+1$, which\nhard to think about, suppose that instead all cows shift by $-1$, while the\nactive positions remain constant throughout the entire process. In this way, the\nrelative positions between the active indices and the cows remain exactly the\nsame. So, if we simulate the process of shifting cows back by $-1$ and keeping\n$A$ constant, we will end up with the same final array as the original process\n(shifted by $T$). \nHere's the output of this shifted order; the pattern is easier to spot now.\n\nINPUT\nN=10 K=3 T=15\nA=[0, 3, 7]\nSIMULATING\nInitial, T = 0: order = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], A = [0, 3, 7]\nT = 1: order_shifted = [1, 2, 0, 4, 5, 6, 3, 8, 9, 7]\nT = 2: order_shifted = [2, 0, 1, 5, 6, 3, 4, 9, 7, 8]\nT = 3: order_shifted = [0, 1, 2, 6, 3, 4, 5, 7, 8, 9]\nT = 4: order_shifted = [1, 2, 0, 3, 4, 5, 6, 8, 9, 7]\nT = 5: order_shifted = [2, 0, 1, 4, 5, 6, 3, 9, 7, 8]\nT = 6: order_shifted = [0, 1, 2, 5, 6, 3, 4, 7, 8, 9]\nT = 7: order_shifted = [1, 2, 0, 6, 3, 4, 5, 8, 9, 7]\nT = 8: order_shifted = [2, 0, 1, 3, 4, 5, 6, 9, 7, 8]\nT = 9: order_shifted = [0, 1, 2, 4, 5, 6, 3, 7, 8, 9]\nT = 10: order_shifted = [1, 2, 0, 5, 6, 3, 4, 8, 9, 7]\nT = 11: order_shifted = [2, 0, 1, 6, 3, 4, 5, 9, 7, 8]\nT = 12: order_shifted = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nT = 13: order_shifted = [1, 2, 0, 4, 5, 6, 3, 8, 9, 7]\nT = 14: order_shifted = [2, 0, 1, 5, 6, 3, 4, 9, 7, 8]\nT = 15: order_shifted = [0, 1, 2, 6, 3, 4, 5, 7, 8, 9]\n\nThe pattern is the following: for every $i$, the values in the range\n$A_i \\le j < A_{i+1}$ always stay in the positions which are in the range\n$A_i \\le j < A_{i+1}$. If we consider these values, the values cyclically shift\nleft by $1$ every minute.\nFor example, look at the indices $3, 4, 5, 6$ in the above output.  The values\nat those indices start as $3, 4, 5, 6$ at $T = 0$, then $4, 5, 6, 3$ at $T=1$,\nthen $5, 6, 3, 4$ at $T=2$, then $6, 3, 4, 5$ at $T=3$, then $3, 4, 5, 6$ at\n$T=4$ (and keeps repeating in this cycle forever).\nSo, for each $j$ such that $A_i \\le j < A_{i+1}$, we cyclically shift it to the\nleft $T$ times modulo $A_{i+1}-A_i$ within the subarray with left endpoint $A_i$\nand right endpoint $A_{i+1}-1$. Finally, at the end, we add back $T$ to the\nfinal position to get back the original indices. \nRichard's code (Solution 1, Python):\n\n# Read in the input\nN, K, T = map(int, input().split())\nA = list(map(int, input().split())) + [N] # append the value N to the sequence\n\nans = [-1] * N # declare an empty final array\n\nfor i in range(K):\n    for j in range(A[i], A[i+1]):\n    \tT_prime = T-(j-A[i]+1)\n\n    \tif T_prime >= 0:\n    \t\tincrease_times = 1 + T_prime // (A[i+1]-A[i]) # integer division is // in python\n    \t\tending_position = (j + increase_times * (A[i+1]-A[i])) % N\n    \telse:\n    \t\t# doesn't move at all\n    \t\tending_position = j\n\n    \tans[ending_position] = j\n\n# Print the output\nprint(\" \".join(map(str, ans)))\n\nRichard's code (Solution 2, C++):\n\n#include <bits/stdc++.h>\nusing namespace std;\n \nconst int mx = 200005;\nint A[mx];\nint ans[mx];\n\nint main(){\n    cin.tie(0)->sync_with_stdio(0);\n    int N, K, T; cin >> N >> K >> T;\n    for(int i = 1; i <= K; i++){\n        cin >> A[i];\n    }\n    A[K+1] = N;\n    for(int i = 1; i <= K; i++){\n        for(int j = A[i]; j < A[i+1]; j++){\n            //where is j relative to A[i]\n            int current_shift = j-A[i];\n            //j moves backwards T times\n            int new_shift = current_shift-T;\n            int diff = A[i+1]-A[i];\n            new_shift = (new_shift % diff + diff) % diff; //take mods to get it back in the range [0, diff-1].\n            \n            //A[i] moves new_shift times, then we shift our perspective by T.\n            ans[(A[i]+new_shift+T) % N] = j;\n        }\n    }\n    for(int i = 0; i < N; i++){\n        cout << ans[i];\n        if(i+1 < N) cout << \" \";\n    }\n    cout << \"\\n\";\n}\n\n",
                "runtime_limit_sentences": [
                    "\n**Note: The time limit for this problem is 4s, 2x the default."
                ],
                "memory_limit_sentences": [],
                "runtime_limit": 4,
                "memory_limit": 256,
                "samples": [
                    {
                    "input": "5 3 4\n0 2 3",
                    "output": "1 2 3 4 0",
                    "explanation": "For the example above, here are the cow orders and $A$ for the first four\ntimesteps:\n\n\nInitial, T = 0: order = [0 1 2 3 4], A = [0 2 3]\nT = 1: order = [3 1 0 2 4]\nT = 1: A = [1 3 4]\nT = 2: order = [3 4 0 1 2]\nT = 2: A = [2 4 0]\nT = 3: order = [2 4 3 1 0]\nT = 3: A = [3 0 1]\nT = 4: order = [1 2 3 4 0]"
                    }
                ],
                "description_no_samples": "\n**Note: The time limit for this problem is 4s, 2x the default.**\nTo celebrate the start of spring, Farmer John's $N$ cows ($1 \\leq N \\leq 2 \\cdot 10^5$) have invented an intriguing new dance, where they stand in a circle and re-order themselves in a predictable way.\n\nSpecifically, there are $N$ positions around the circle, numbered sequentially from $0$ to $N-1$, with position $0$ following position $N-1$.  A cow resides at each position.  The cows are also numbered sequentially from $0$ to $N-1$.  Initially, cow $i$ starts in position $i$.  You are told a set of $K$ positions $0=A_1<A_2< \\ldots< A_K<N$ that are \"active\", meaning the cows in these positions are the next to move ($1 \\leq K \\leq N$).  \n\nIn each minute of the dance, two things happen.  First, the cows in the active positions rotate: the cow at position $A_1$ moves to position $A_2$, the cow at position $A_2$ moves to position $A_3$, and so on, with the cow at position $A_K$ moving to position $A_1$.  All of these $K$ moves happen simultaneously, so the after the rotation is complete, all of the active positions still contain exactly one cow.  Next, the active positions themselves shift:\n$A_1$ becomes $A_1+1$, $A_2$ becomes $A_2+1$, and so on (if $A_i = N-1$ for some active position, then $A_i$ circles back around to $0$).\n\nPlease calculate the order of the cows after $T$ minutes of the dance ($1\\le T\\le 10^9$).\n\nINPUT FORMAT (input arrives from the terminal / stdin):\nThe first line contains three integers $N$, $K$, and $T$.\n\nThe second line contains $K$ integers representing the initial set of active positions\n$A_1,A_2, \\ldots A_K$.  Recall that $A_1 = 0$ and that these are given in increasing order.\n\nOUTPUT FORMAT (print output to the terminal / stdout):\nOutput the order of the cows after $T$ minutes, starting with the cow in position $0$, separated by\nspaces.\n\n",
                "num_samples": 1,
                "solution_python3": "\nN, K, T = map(int, input().split())\nA = list(map(int, input().split())) + [N]\n\nans = [-1] * N\n\nfor i in range(K):\n    for j in range(A[i], A[i+1]):\n        T_prime = T - (j - A[i] + 1)\n\n        if T_prime >= 0:\n            increase_times = 1 + T_prime // (A[i+1] - A[i])\n            ending_position = (j + increase_times * (A[i+1] - A[i])) % N\n        else:\n            ending_position = j\n\n        ans[ending_position] = j\n\nprint(\" \".join(map(str, ans)))\n",
                "solution_english": "(Analysis by Richard Qi)\nFor $N \\le 1000, T \\le 10000$, we can directly simulate the process described by\nthe problem. Initialize an array corresponding to the current order of the cows\n($0$ to $N-1$). Call this array \"order\". \nFor each timestep, first update \"order\" by shifting according to the indices\nlisted in $A$ (you can create a copy of \"order\" and change the values in the\ncopy, or swap/change the values in place). Then, update $A$ by adding one to\neach element and taking modulo $N$. \nRichard's code (C++):\n\n\n\nFor the full solution, it helps to work out some examples of the process on\npaper, or use your brute force solution to list out some examples for you.\nHere's the output of a brute force solution on a slightly larger test case:\n\nINPUT\nN=10 K=3 T=15\nA=[0, 3, 7]\nSIMULATING\nInitial, T = 0: order = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], A = [0, 3, 7]\nT = 1: order = [7, 1, 2, 0, 4, 5, 6, 3, 8, 9]\nT = 1: A = [1, 4, 8]\nT = 2: order = [7, 8, 2, 0, 1, 5, 6, 3, 4, 9]\nT = 2: A = [2, 5, 9]\nT = 3: order = [7, 8, 9, 0, 1, 2, 6, 3, 4, 5]\nT = 3: A = [3, 6, 0]\nT = 4: order = [6, 8, 9, 7, 1, 2, 0, 3, 4, 5]\nT = 4: A = [4, 7, 1]\nT = 5: order = [6, 3, 9, 7, 8, 2, 0, 1, 4, 5]\nT = 5: A = [5, 8, 2]\nT = 6: order = [6, 3, 4, 7, 8, 9, 0, 1, 2, 5]\nT = 6: A = [6, 9, 3]\nT = 7: order = [6, 3, 4, 5, 8, 9, 7, 1, 2, 0]\nT = 7: A = [7, 0, 4]\nT = 8: order = [1, 3, 4, 5, 6, 9, 7, 8, 2, 0]\nT = 8: A = [8, 1, 5]\nT = 9: order = [1, 2, 4, 5, 6, 3, 7, 8, 9, 0]\nT = 9: A = [9, 2, 6]\nT = 10: order = [1, 2, 0, 5, 6, 3, 4, 8, 9, 7]\nT = 10: A = [0, 3, 7]\nT = 11: order = [8, 2, 0, 1, 6, 3, 4, 5, 9, 7]\nT = 11: A = [1, 4, 8]\nT = 12: order = [8, 9, 0, 1, 2, 3, 4, 5, 6, 7]\nT = 12: A = [2, 5, 9]\nT = 13: order = [8, 9, 7, 1, 2, 0, 4, 5, 6, 3]\nT = 13: A = [3, 6, 0]\nT = 14: order = [4, 9, 7, 8, 2, 0, 1, 5, 6, 3]\nT = 14: A = [4, 7, 1]\nT = 15: order = [4, 5, 7, 8, 9, 0, 1, 2, 6, 3]\n\nTry looking at the above output; notice any patterns? There are two similar\nsolutions that naturally follow from patterns that can be found in the above\noutput. The solution code for each solution is at the bottom of the page.\n Solution 1:   Look at a single cow's journey over time. For example,\nlook at cow $0$. Cow $0$ started at position $0$ at $T = 0$, then was at\nposition $3$ during $1 \\le T \\le 3$, then was at position $6$ during\n$4 \\le T \\le 6$. Other than $T=0$, cow $0$ appears to stay at a position for\nexactly $3$ minutes, then move $3$ positions forward, then stay at that position\nfor exactly $3$ minutes, etc.\nThis is no coincidence: cow $1$ follows the same behavior! Cow $1$ starts at\nposition $1$ for $0 \\le T \\le 1$, then goes to position $4$ for $2 \\le T \\le 4$,\nthen goes to position $7$ for $5 \\le T \\le 7$. In fact, if you examine further,\ncow $2$ also exhibits this behavior, moving $3$ positions forward every $3$\nminutes. Cow $3$ moves $4$ positions forward every $4$ minutes, which is\nslightly different from cows $0-2$, but still follows the pattern of moving $i$\npositions every $i$ minutes. \nA natural question to ask is \"why is this happening?\". We will prove why this is\nhappening for cow $2$. Because $A_1 = 0$ and $A_2 = 3$, cow $2$ is \"between\"\nthese two active positions and does not move until $T = 2$, when\n$A_1 = 2, A_2 = 5$. During this timestep, cow $2$ moves to position $5$. So,\nafter this timestep, cow $2$ is at position $5$, $A_1 = 3, A_2 = 6$. Notice that\nat the very beginning of timestep $T=3$, cow $2$ is still between the active\npositions $A_1$ and $A_2$. In fact, cow $2$ is exactly two positions after $A_1$\nand $1$ position before $A_2$, which was true at $T=0$ as well.\nThis motivates looking at cow $2$ in the following way: observe cow $2$ relative\nto active positions $A_1$ and $A_2$. Cow $2$ is always between $A_1$ and $A_2$,\nbecause cow $2$ stays in place while $A_1$ and $A_2$ increase at a rate of $1$\nunit per second, and as soon as $A_1$ is equal to the position of cow $1$, cow\n$1$ jumps ahead $A_2-A_1$ positions and is now just behind position $A_2$. This\nalso shows why cow $j$ jumps exactly $A_{i+1}-A_i$ positions every $A_{i+1}-A_i$\ntimesteps (if $A_i \\le j < A_{i+1}$).\nWe use the above observation to solve the problem in the following way: first,\ndefine $A_{K+1} = N$ for convenience. Then, for each $i$ from $i=1$ to $i=K$,\nconsider all cows $j$ in the range $A_i \\le j < A_{i+1}$.\nCow $j$ first stays in place for $j-A_i$ minutes, during which $A_i$ increases\nto meet $j$. Then, on the $j-A_i+1$th minute, $j$ jumps forward $A_{i+1}-A_i$\npositions.\nAfter this point, there are $T' = T-(j-A_i+1)$ minutes left to go. From then on,\nevery $A_{i+1}-A_i$ minutes, cow $j$'s position increases by $A_{i+1}-A_i$. So,\nduring this phase, cow $j$'s position increases\n$\\lfloor \\frac{T'}{A_{i+1}-A_i} \\rfloor$ times, and each time, cow $j$'"
            }}
